//ConvertToSVG.jsx
//
//Convert the InDesign page items to SVG. This is very much a work in progress.
//
//by Olav Martin Kvern
//Distributed by Silicon Publishing, Inc., for PEPCON, San Francisco, 2012.
//
//Our web site says, "Silicon Publishing, Inc. provides electronic publishing solutions and customizations 
//that automate the distribution of information between multiple sources and destinations." But what does
//that really mean? We make custom software for publishing. Some of it is for intense, data-driven, high-
//volume applications--think: directories, catalogs, and customized itineraries. Some of it is for web-to-print 
//or print-to-web applications--think: business cards, flyers, brochures, data sheets. Some of it is none of the 
//above. Use your imagination--if there's some chance that we can make your work easier, drop us a line! 
//sales@siliconpublishing.com
//
#target 'indesign'
//
//A couple of globals (sorry, got lazy):
var xOffset = 0;
var yOffset = 0;
var scaleFactor = 1;
main();
function main(){
	app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;
	var objectList = new Array;
	if(app.documents.length > 0){
		if(app.selection.length > 0){
			objectList = displayDialog();
			if(objectList.length > 0){
				convertToSVG(objectList);
				alert("Done converting to SVG.");
			}
			else{
				alert("No qualifying object selected. Please select a rectangle, ellipse, polygon, graphic line, or group, and try again.");
			}
		}
		else{
			alert("Please select an object or objects and try again.");			
		}
	}
}
function convertToSVG(objectList){
	var scaleElement, elementName, xmlString;
	//Have to have the SVG namespace.
	var headerString = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\r<!--Generated by the ConvertToSVG.jsx script from www.siliconpublishing.com/resources -->\r";
	var xml = new XML(headerString);
	var defs = new XML("<defs></defs>");
	xml.appendChild(defs);
	//Figure out the bounds for the SVG.
	xml = setSVGBounds(objectList, xml);
	for(counter = 0; counter < objectList.length; counter++){
		//Add a group to the <Graphic> element.
		pageItem = app.documents.item(0).pageItems.itemByID(objectList[counter]);
		elementName = String(pageItem.constructor.name + pageItem.id);
		xmlString = "<g id=\"" + elementName + "\" transform=\"scale(" + scaleFactor + ")\"></g>"
		groupElement = new XML(xmlString);
		xml.appendChild(groupElement);
		if(pageItem.getElements()[0].constructor.name == "Group"){
			for(groupItemCounter = pageItem.pageItems.length-1; groupItemCounter >= 0; groupItemCounter--){
			//for(groupItemCounter = 0; groupItemCounter < pageItem.pageItems.length; groupItemCounter++){
				xml = processPageItem(pageItem.pageItems.item(groupItemCounter), xml);
			}
		}
		else{
			xml = processPageItem(pageItem, xml);
		}
	}
	saveFile(xml);
}
function displayDialog(){
	var objectList = new Array;
	var dialog = app.dialogs.add({name:"Convert to SVG"});
	with(dialog.dialogColumns.add()){
		with(dialogRows.add()){
			with(dialogColumns.add()){
				with(dialogRows.add()){
					with(dialogColumns.add()){
						staticTexts.add({staticLabel:"Scale Factor:"});
					}
					with(dialogColumns.add()){
						var scaleFactorField = percentEditboxes.add({editValue:100});
					}
				}
			}
		}
	}
	var myResult = dialog.show();
	if(myResult == true){
		scaleFactor = scaleFactorField.editValue * .01;
		objectList = buildObjectList(objectList);
	}
	dialog.destroy();
	return objectList;
}
function buildObjectList(objectList){
	for(var counter = 0; counter < app.selection.length; counter++){
		switch(app.selection[counter].constructor.name){
			case "Rectangle":
			case "Oval":
			case "Polygon":
			case "GraphicLine":
			case "Group":
				objectList.push(app.selection[counter].id);
				break;
		}
	}
	return objectList;
}
function saveFile(xml){
	var file = File.saveDialog ("Save SVG as");
	if(file != null){
		file.open ("w");
		file.encoding = "UTF-8";
		file.write("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r" + xml.toXMLString());
		file.close();
	}
}
function processPageItem(pageItem, xml){
	xml = makeSVGPath(pageItem, xml);
	return xml;
}
function setSVGBounds(objectList, xml){
	var pageItem;
	var bounds = app.documents.item(0).pageItems.itemByID(objectList[0]).visibleBounds;
	//Set some initial bounds.
	var x1 = bounds[1];
	var y1 = bounds[0];
	var x2 = bounds[2];
	var y2 = bounds[3];
	for(var counter = 0; counter < objectList.length; counter++){
		pageItem = app.documents.item(0).pageItems.itemByID(objectList[counter]);
		bounds = app.documents.item(0).pageItems.itemByID(objectList[counter]).visibleBounds;
		//Compare the bounds values to the stored bounds.
		//If a given bounds value is less than (for x1 and y1) or 
		//greater than (for x2 and y2) the stored value,
		//then replace the stored value with the bounds value.
		if (bounds[0] < y1){
			y1 = bounds[0];
		}
		if (bounds[1] < x1){
			x1 = bounds[1];
		}
		if (bounds[2] > y2){
			y2 = bounds[2];
		}
		if (bounds[3] > x2){
			x2 = bounds[3];
		}		
	}
	//At this point, we should have a valid visible bounds for 
	//all of the specified page items.
	var width = x2-x1;
	var height = y2-y1;
	xOffset = x1;
	yOffset = y1;
	//Set the bounds of the graphic element.
	xml.@width = String(width * scaleFactor) + "pt";
	xml.@height = String(height * scaleFactor) + "pt";
	xml.@viewBox = "0 0 " + String(width * scaleFactor) + " " +String(height * scaleFactor)
	return xml;
}
function makeSVGPath(pageItem, xml){
	var string = "";
	//Set localCoordinates to false to get the object position in page coordinates,
	//rather than removing the offsets.
	var localCoordinates = true;
	//
	for(var counter = 0; counter < pageItem.paths.length; counter++){
		entirePath = pageItem.paths.item(counter).entirePath;
		//Remove the offsets if using local coordinates.
		if(localCoordinates == true){
			entirePath = removeOffsets(entirePath);
		}
		string += convertPath(entirePath, pageItem.paths.item(counter).pathType);
	}
	var pathElement = new XML("<path>");
	pathElement.@d = string;
	pathElement = getFormatting(pageItem, pathElement, xml);
	//Add to the last <g> (group) element
	xml.g[xml.g.length()-1].appendChild(pathElement);
	//$.writeln(xml.toXMLString());
	return xml;
}
function getFormatting(pageItem, pathElement, xml){
	var strokeWidth;
	if(pageItem.strokeColor.name != "None"){
		var strokeWeight = pageItem.strokeWeight;
		if(pageItem.strokeColor.constructor.name != "Gradient"){
			var strokeColor = getRGBColor(pageItem.strokeColor, pageItem.strokeTint) ;
			strokeWidth = strokeWeight;
			styleString = "stroke-width:" + strokeWidth + "pt; stroke:" + strokeColor + ";";
			pathElement.@style = styleString;
			/*
			pathElement.@stroke-width = strokeWidth;
			pathElement.@stroke = strokeColor;
			*/
		}
		else{
			var gradientXML;
			if(pageItem.strokeColor.type == GradientType.LINEAR){
				gradientXML = new XML("<linearGradient></linearGradient>");
			}
			else{
				gradientXML = new XML("<radialGradient></radialGradient>");
			}
			gradientXML.@id = "gradientStroke_" + pageItem.id;
			gradientXML.@gradientUnits = "userSpaceOnUse";
			var gradientBounds = new Array;
			gradientBounds.push (new Array(pageItem.geometricBounds[1], pageItem.geometricBounds[0]));
			gradientBounds.push (new Array(pageItem.geometricBounds[3], pageItem.geometricBounds[2]));
			gradientBounds = removeOffsets(gradientBounds);
			gradientXML.@x1 = gradientBounds[0][0] + "";
			gradientXML.@y1 = gradientBounds[0][1] + "";
			gradientXML.@x2 = gradientBounds[1][0] + "";
			gradientXML.@y2 = gradientBounds[1][0] + "";
			var gradientStopXML;
			for(var stopCounter = 0; stopCounter < pageItem.strokeColor.gradientStops.length; stopCounter++){
				gradientStopXML = new XML("<stop></stop>");
				gradientStopXML.@offset = String(pageItem.strokeColor.gradientStops.item(stopCounter).location * .01);
				gradientStopXML.@stop-color = "#" + getRGBColor(pageItem.strokeColor.gradientStops.item(stopCounter).stopColor, pageItem.strokeTint);
				gradientXML.appendChild(gradientStopXML);
			}
			xml.defs.appendChild(gradientXML);
			pathElement.@stroke="url(#gradientStroke_" + pageItem.id + ")";
			pathElement.@stroke-width= strokeWeight;
		}
	}
	else{
		pathElement.@stroke="none" 
		pathElement.@stroke-width="0";
	}
	if(pageItem.fillColor.name != "None"){
		if(pageItem.fillColor.constructor.name != "Gradient"){
			var fillColor = getRGBColor(pageItem.fillColor, pageItem.fillTint);
			pathElement.@fill="#" + fillColor;
		}
		else{
			var gradientXML;
			if(pageItem.fillColor.type == GradientType.LINEAR){
				gradientXML = new XML("<linearGradient></linearGradient>");
			}
			else{
				gradientXML = new XML("<radialGradient></radialGradient>");				
			}
			gradientXML.@id = "gradientFill_" + pageItem.id;
			gradientXML.@gradientUnits = "userSpaceOnUse";
			var gradientBounds = new Array;
			gradientBounds.push (new Array(pageItem.geometricBounds[1], pageItem.geometricBounds[0]));
			gradientBounds.push (new Array(pageItem.geometricBounds[3], pageItem.geometricBounds[2]));
			gradientBounds = removeOffsets(gradientBounds);
			gradientXML.@x1 = gradientBounds[0][0] + "";
			gradientXML.@y1 = gradientBounds[0][1] + "";
			gradientXML.@x2 = gradientBounds[1][0] + "";
			gradientXML.@y2 = gradientBounds[1][0] + "";
			var gradientStopXML;
			for(var stopCounter = 0; stopCounter < pageItem.fillColor.gradientStops.length; stopCounter++){
				gradientStopXML = new XML("<stop></stop>");
				gradientStopXML.@offset = String(pageItem.fillColor.gradientStops.item(stopCounter).location * .01);
				gradientStopXML.@style = "stop-color:#" + getRGBColor(pageItem.fillColor.gradientStops.item(stopCounter).stopColor, pageItem.fillTint) + ";";
				gradientXML.appendChild(gradientStopXML);
			}
			xml.defs.appendChild(gradientXML);
			pathElement.@fill="url(#gradientFill_" + pageItem.id + ")";
		}
	}
	else{
		pathElement.@fill="none";
	}
	return pathElement;
}
function getRGBColor(color, tint){
	var colorString, newColor, newColorArray;;
	if(color.name == "None"){
		return "None";
	}
	if((color.name == "Black")||(color.name=="Registration")){
		if((tint == 100)||(tint == -1)){
			return "000000";
		}
		else{
			tint = tint * .01;
			newColor = app.documents.item(0).colors.add();
			newColor.name = "dummyColor";
			newColor.colorValue = new Array(0, 0, 0, 100);
			newColor.space = ColorSpace.CMYK;
			newColorArray = new Array(newColor.colorValue[0]*tint, newColor.colorValue[1]*tint, newColor.colorValue[2]*tint, newColor.colorValue[3]*tint);
			newColor.colorValue = newColorArray;
			newColor.space = ColorSpace.RGB;
			colorString = rgbToHex(newColor.colorValue[0], newColor.colorValue[1], newColor.colorValue[2]);
			newColor.remove();
			return colorString;
		}
	}
	if(color.name == "Paper"){
		return "FFFFFF";
	}
	var newColor = color.duplicate();
	if((tint >= 0)&&(tint != 100)){
		tint = tint * .01;
		newColor.space = ColorSpace.CMYK;
		newColorArray = new Array(newColor.colorValue[0]*tint, newColor.colorValue[1]*tint, newColor.colorValue[2]*tint, newColor.colorValue[3]*tint);
		newColor.colorValue = newColorArray;
	}
	newColor.space = ColorSpace.RGB;
	colorString = rgbToHex(newColor.colorValue[0], newColor.colorValue[1], newColor.colorValue[2]);
	newColor.remove();
	return colorString;
}
//Remove offsets
function removeOffsets(array){
	var newArray = new Array;
	for(var counter = 0; counter < array.length; counter++){
		switch(array[counter].length){
			case 2:
				newArray.push([array[counter][0]-xOffset, array[counter][1]-yOffset]);
			break;
			case 3:
				newArray.push([[array[counter][0][0]-xOffset, array[counter][0][1]-yOffset], [array[counter][1][0]-xOffset, array[counter][1][1]-yOffset], [array[counter][2][0]-xOffset, array[counter][2][1]-yOffset]]);
			break;
		}
	}
	//$.writeln(newArray.toSource());
	return newArray;
}
//Takes a path point array and returns a string suitable for use in <Path> element data attribute.
function convertPath(entirePath, pathType){
	var point, anchor, nextAnchor;
	var string = "";
	for(var counter = 0; counter < entirePath.length; counter++){
		point = entirePath[counter];
		if(counter < entirePath.length-1){
			nextPoint = entirePath[counter+1];
		}
		else{
			if(pathType == PathType.CLOSED_PATH){
				nextPoint = entirePath[0];
			}
			else{
				nextPoint = null;
			}
		}
		if(nextPoint != null){
			anchor = getAnchor(point);
			//nextAnchor = getAnchor(nextPoint);
			if(counter == 0){
				//moveto the first point on the path.
				string += "M " + anchor[0] + " " + anchor[1] + " "
			}
			switch(true){
				case(isCurvePoint(point)&&isCurvePoint(nextPoint)):
					//curveto current point right direction, next point right direction, next point anchor.
					string += "C " + point[2][0] + " " + point[2][1] + " " + nextPoint[0][0] + " " + nextPoint[0][1] + " " + nextPoint[1][0] + " " + nextPoint[1][1] + " ";				
				break;
				case(!isCurvePoint(point)&&isCurvePoint(nextPoint)):
					//curveto current point anchor, next point right direction, next point anchor.
					string += "C " + point[0] + " " + point[1] + " " + nextPoint[0][0] + " " + nextPoint[0][1] + " " + nextPoint[1][0] + " " + nextPoint[1][1] + " ";
				break;
				case(isCurvePoint(point)&&!isCurvePoint(nextPoint)):
					//curveto current point right direction, next point anchor, next point anchor.
					string += "C " + point[2][0] + " " + point[2][1] + " " + nextPoint[0] + " " + nextPoint[1] + " " + nextPoint[0] + " " + nextPoint[1] + " ";
				break;
				case(!isCurvePoint(point)&&!isCurvePoint(nextPoint)):
					//lineto current point anchor, next point anchor.
					string += "L " + nextPoint[0] + " " + nextPoint[1] + " ";
				break;
			}
		}
	}
	//closepath
	if(pathType == PathType.CLOSED_PATH){
		string += "Z ";
	}
	return string;
}
function isCurvePoint(array){
	var result = false;
	if(array.length == 3){
		result = true;
	}
	return result;	
}	
function getAnchor(array){
	var anchor;
	//If the point is a curve point, then the anchor is the second array in the array.
	if(array.length == 3){
		anchor = array[1];
	}
	else{
		anchor = array;
	}
	return anchor;
}
function rgbToHex(r, g, b){
	return toHex(r)+toHex(g)+toHex(b)
}
function toHex(n) {
	n = parseInt(n,10);
	if (isNaN(n)) return "00";
	n = Math.max(0,Math.min(n,255));
	return "0123456789ABCDEF".charAt((n-n%16)/16) + "0123456789ABCDEF".charAt(n%16);
}
